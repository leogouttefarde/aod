\documentclass[a4paper, 10pt, french]{article}
% Préambule; packages qui peuvent être utiles
   \RequirePackage[T1]{fontenc}        % Ce package pourrit les pdf...
   \RequirePackage{babel,indentfirst}  % Pour les césures correctes,
                                       % et pour indenter au début de chaque paragraphe
   \RequirePackage[utf8]{inputenc}   % Pour pouvoir utiliser directement les accents
                                     % et autres caractères français
   \RequirePackage{lmodern,tgpagella} % Police de caractères
   \textwidth 17cm \textheight 25cm \oddsidemargin -0.24cm % Définition taille de la page
   \evensidemargin -1.24cm \topskip 0cm \headheight -1.5cm % Définition des marges
   \RequirePackage{latexsym}                  % Symboles
   \RequirePackage{amsmath}                   % Symboles mathématiques
   \RequirePackage{tikz}   % Pour faire des schémas
   \RequirePackage{graphicx} % Pour inclure des images
   \RequirePackage{listings} % pour mettre des listings
% Fin Préambule; package qui peuvent être utiles

\title{Rapport de TP 4MMAOD : Génération de patch optimal}
\author{
{\sc Gouttefarde} Léo (groupe 5)\\
{\sc Piellard} Jérémie (groupe 2)
}
\begin{document}

\maketitle

Dans toute la suite nous noterons $N$ le nombre de lignes du fichier d'entrée et $M$ celui du fichier de sortie.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Principe de notre programme}
Notre programme \texttt{computePatchOpt} est réalisé en C\texttt{++} afin d'assurer les meilleures performances tout en profitant des nombreuses fonctionnalités d'un langage orienté objet.\\

Afin d'accéder rapidement aux fichiers d'entrée et de sortie, nous les stockons entièrement en mémoire.
Nous avons ainsi réalisé une classe \texttt{File} dédiée à cette tâche.\\

Pour le calcul du patch optimal, nous avons créé une classe \texttt{Solver}.
Cette classe résoud les équations de Bellman de manière itérative.

On crée un tableau d'états de taille $(M+1)\times(N+1)$.
Un état est représenté par un coût optimal et l'opération nécessaire pour y arriver (on peut en déduire l'état précédent), soit deux entiers.

On commence par remplir les conditions aux bords
(état $(0,j)$ accessible uniquement par $j$ additions,
état $(i,0)$ accessible uniquement par destructions).

Ensuite on calcule les autres coûts en parcourant la matrice par ligne
(c'est-à-dire à $j$ constant).
Le calcul du coût de l'addition, la substitution ou la destruction sont simples.
Pour le coût de la multi-destruction, on retient l'indice le plus avantageux
et on le met à jour à chaque incrémentation de $i$ (cela évite de parcourir une nouvelle fois toute la ligne).\\

Quand la matrice des états est remplie, pour écrire le patch optimal on part de l'état $(i_{max}, j_{max})$
et on remonte la suite des instructions effectuées pour retrouver l'état $(0,0)$.
On stocke ces opérations dans une liste, que l'on parcourt à nouveau afin d'écrire le patch final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analyse du coût théorique}

  \subsection{Nombre  d'opérations en pire cas\,: }
    Il est en $\Theta(NM)$.\\

    \textbf{Justification\,:} Pour calculer les coûts, on parcourt exactement une fois le tableau the taille $((N+1)\times(M+1))$.
    Le traitement de chaque case a un coût fixe car on teste systématiquement les 4 opérations possibles (sauf pour les cases $i=0$ ou $j=0$ qui ont un coût moindre).

    Le coût de lecture des fichiers d'entrée et de sortie ($\Theta(N)$ et $\Theta(M)$ respectivement) sont négligeables.

    Enfin le coût d'écriture du patch est en pire cas en $\Theta(M)$ puisque le patch est au plus constitué de $2M$ lignes.

  \subsection{Place mémoire requise\,: }
    Il est en $\Theta(NM)$.\\

    \textbf{Justification\,:} On stocke entièrement les deux fichiers en mémoire : coût $\Theta(N+M)$.

    On a également besoin de stocker un tableau $(M+1)\times(N+1)$ : coût $(\Theta(NM)$).

    Enfin pour l'écriture du patch on utilise temporairement une liste de taille maximale $N$ : coût $\Theta(N)$.

  \subsection{Nombre de défauts de cache sur le modèle CO\,: }
    \paragraph{Justification\,: }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compte rendu d'expérimentation}
  \subsection{Conditions expérimentales}

    \subsubsection{Description synthétique de la machine\,:} 

    La machine utilisée pour notre test est une machine de la salle E203.
    Cette machine a un processeur Intel Core i5 4 coeurs à 3,3 Ghz et 16 Go de mémoire RAM.

    \subsubsection{Méthode utilisée pour les mesures de temps\,: } 

    Le code a été compilé avec l'option -O3.
    Les mesures sont effectuées dans le code C++ lui-même (et pas dans le Makefile).
    Pour que ces mesures prennent en compte la désallocation mémoire, nous avons
    alloué et désalloué manuellement une instance de notre solveur.

    Nous avons fait alterné les tests pour faire les mesures pour éviter que
    le système d'exploitation mette en cache les fichiers ce qui aurait faussé les temps d'exécution.
    Cependant nous obtenons des mesures semblables en passant 5 fois le même test à la suite.

    Les mesures sont en millisecondes.
    Il faut noter que la machine offre une précision de mesure maximale de 20 ms.

  \subsection{Mesures expérimentales}

    \begin{figure}[h!]
      \begin{center}
        \begin{tabular}{|l||r||r|r|r||}
          \hline
          \hline
            & coût         & temps     & temps   & temps \\
            & du patch     & min       & max     & moyen \\
          \hline
          \hline
            benchmark 1 & 2540 & 20 & 20 & 20 \\
          \hline
            benchmark 2 & 3120 & 80 & 90 & 82 \\
          \hline
            benchmark 3 & 809 & 160 & 180 & 170 \\
          \hline
            benchmark 4 & 1708 & 350 & 370 & 360 \\
          \hline
            benchmark 5 & 7553 & 460 & 470 & 468 \\
          \hline
            benchmark 6 & 37027 & 2050 & 2070 & 2060 \\
          \hline
          \hline
        \end{tabular}
        \caption{Mesures des temps minimum, maximum et moyen de 5 exécutions pour les 6 benchmarks.}
        \label{table-temps}
      \end{center}
    \end{figure}

\subsection{Analyse des résultats expérimentaux}

Voici ci-dessous le graphe du temps d'exécution divisé par $NM$ en fonction de $NM$.
Nous avons créé nous même quelques patchs pour tester d'autres valeurs de $NM$ et compléter le graphe.
On constate que le temps d'exécution est bien proportionnel à la quantité $NM$.


\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{exec.png}
\caption{Temps d'exécution divisé par $NM$ en fonction de $NM$}
\end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Question\,: et  si le coût d'un patch était sa taille en octets ?}
    Dans le cas où le coût d'un patch est sa taille en octet,
on peut garder le même programme en changeant simplement le coût des opérations.
Les coûts deviennent:

\begin{itemize}
\item addition de la ligne j après la ligne k : $taille("+\ k\backslash n") + taille(ligne_j)$
\item substitution de la ligne j par la ligne k : $taille("=\ k\backslash n") + taille(ligne_j)$
\item suppression de la ligne i : $taille("d\ i\backslash n")$
\item suppression de n lignes après la ligne i : $taille("D\ i\ j\backslash n")$
\end{itemize}

% {\em Préciser le principe de la résolution choisie (parmi celles vues en cours); donner  les modifications à apporter (soit à vos  équations, soit à votre programme, au choix) 
% pour s'adapter à cette nouvelle fonction de coût. 
% }

\end{document}
%% Fin mise au format

